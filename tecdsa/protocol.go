package tecdsa

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"github.com/roasbeef/go-go-gadget-paillier"
	"hash"
	"math/big"
)

// TODO: gotta be the same function somewhere else ...? maybe not public tho :/
func MakeRandoIntWithOrder(N *big.Int) *big.Int {
	randoIntBytes := make([]byte, N.BitLen() / 8)
	rand.Read(randoIntBytes)
	randoInt := new(big.Int).SetBytes(randoIntBytes)
	randoInt.Mod(randoInt, N) // make sure rando is in ZN
	return randoInt
}

type TwoPartyTrustedDealerProtocol struct {
	theCurve elliptic.Curve
	hasher  func() hash.Hash

	// dealer items
	sessionSK *paillier.PrivateKey

	// shared state for protocol
	sessionId []byte // something like hash of session keys?
	cKey []byte
	sessionPK *paillier.PublicKey

	// player-specific session state
	keyShare *big.Int
	sessionOrd *big.Int

	// player-specific round state
	signKey *big.Int
	p1CP    *SignCommitProve
	p2CP    *SignCommitProve
}
type TPTDProtocol TwoPartyTrustedDealerProtocol // abbreviation :)

func NewProtocol(theCurve elliptic.Curve, hasher  func() hash.Hash) *TPTDProtocol {
	return &TPTDProtocol{theCurve: theCurve, hasher: hasher}
}

func (p *TPTDProtocol) MakeKeyShares(privKey *big.Int) (*big.Int, *big.Int, error) {
	Zq := p.theCurve.Params().N

	// in the protocol i want to simulate we assume:
	// . alice has an existing public + private key pair
	// . alice acts as a trusted dealer and creates multiplicative shares of the private key x - which we call x1, x2
	x1 := MakeRandoIntWithOrder(Zq)

	x2 := new(big.Int).ModInverse(x1, Zq)
	x2.Mul(x2, privKey)
	x2.Mod(x2, Zq)

	checkX := new(big.Int).Mul(x1, x2)
	checkX.Mod(checkX, Zq)

	if privKey.Cmp(checkX) != 0 {
		return nil, nil, fmt.Errorf("x1 and x2 should be multiplicative shares of x: %v, %v", x1, x2)
	}

	return x1, x2, nil
}

// P1 is considered to be the 'trusted dealer'
func (p *TPTDProtocol) InitP1Session(keyShare *big.Int) ([]byte, []byte, *paillier.PublicKey, error) {
	// dealer also defines parameters for Paillier encryption - if all goes according to plan only dealer's key pair is
	//  necessary. that is, the assumption is that dealer's public key is communicated to p2 and that is sufficient for the
	//  protocol. further, we want to assume that a fresh set of Paillier parameters is generated for each signing interaction.
	p.sessionSK, _ = paillier.GenerateKey(rand.Reader, 2048) // TODO: config params?
	p.sessionPK = &p.sessionSK.PublicKey

	/*
	TODO: Lindell's protocol assumes (?) that the Paillier key is generated by p1 and stored. cKey - the encryption
	 of p1's key share - is calculated, transmitted to p2 and also stored. If we don't want to do this - to avoid
	 storing the Paillier's keys for example - it's unclear that we can consider p1 a 'trusted dealer'...?
	 */
	var err error
	p.cKey, err = paillier.Encrypt(p.sessionPK, keyShare.Bytes())
	if err != nil {
		return nil, nil, nil, err
	}

	sessionBytes, err := json.Marshal(p.sessionSK)
	if err != nil {
		return nil, nil, nil, err
	}
	h := p.hasher()
	h.Write(sessionBytes)
	p.sessionId = h.Sum(nil)

	p.keyShare = keyShare

	p.sessionOrd = big.NewInt(0)

	return p.cKey, p.sessionId, p.sessionPK, nil
}

func (p *TPTDProtocol) InitP2Session(keyShare *big.Int, p1Ckey, sessionId []byte, sessionPK *paillier.PublicKey) error {

	p.keyShare = keyShare
	p.cKey = p1Ckey
	p.sessionId = sessionId

	p.sessionOrd = big.NewInt(0)

	p.sessionPK = sessionPK

	return nil
}

func (p *TPTDProtocol) getSessionOrd() int64 {
	return p.sessionOrd.Int64()
}

func computeChallenge(hasher hash.Hash, Gx, Tx, Ax *big.Int, optIdent []byte) *big.Int {
	hasher.Write(Gx.Bytes())
	hasher.Write(Tx.Bytes())
	hasher.Write(Ax.Bytes())
	hasher.Write(optIdent)
	return new(big.Int).SetBytes(hasher.Sum(nil))
}

// generates a Schnorr proof of knowledge of the discrete logarithm of the key, with commitment through the Fiat-Shamir transformation
// https://tools.ietf.org/html/rfc8235
func (p *TPTDProtocol) commitProve(A *ecdsa.PrivateKey, optIdent []byte) (r, tx, ty *big.Int) {

	hasher := p.hasher()
	theCurve := p.theCurve

	v := MakeRandoIntWithOrder(theCurve.Params().N)
	tx, ty = theCurve.ScalarBaseMult(v.Bytes())

	// prover computes c = H(g, y, t)
	c := computeChallenge(hasher, theCurve.Params().Gx, tx, A.X, optIdent)

	// prover computes r = v - cx mod Zq and returns r to verifier.
	r = new(big.Int).Mul(c, A.D)
	r.Sub(v, r)
	r.Mod(r, theCurve.Params().N)

	return
}

// TODO: could cache calculation of generator...
func (p *TPTDProtocol) isCurveGenerator(x, y *big.Int) bool {
	Gx, Gy := p.theCurve.ScalarBaseMult(big.NewInt(1).Bytes())
	if Gx.Cmp(x) == 0 && Gy.Cmp(y) == 0 {
		return true
	}
	return false
}

func (p *TPTDProtocol) proveVerify(r, Tx, Ty, Ax, Ay *big.Int, optIdent []byte) bool {

	theCurve := p.theCurve
	hasher := p.hasher()

	// check that point is valid and non-trivial
	if !theCurve.IsOnCurve(Ax, Ay) || p.isCurveGenerator(Ax, Ay) {
		return false
	}

	// verifier computes challenge
	c := computeChallenge(hasher, theCurve.Params().Gx, Tx, Ax, optIdent)

	// verifier checks whether t = g^r * y^c.
	x1, y1 := theCurve.ScalarBaseMult(r.Bytes())
	x2, y2 := theCurve.ScalarMult(Ax, Ay, c.Bytes())
	zx, zy := theCurve.Add(x1, y1, x2, y2)

	if Tx.Cmp(zx) != 0 || Ty.Cmp(zy) != 0 {
		return false
	}
	return true
}

func (p *TPTDProtocol) generateSignKeyAndProof() *SignCommitProve {

	p.signKey = MakeRandoIntWithOrder(p.theCurve.Params().N) // generate and save signKey

	Rx, Ry := p.theCurve.ScalarBaseMult(p.signKey.Bytes())
	R1 := ecdsa.PublicKey{Curve:p.theCurve, X: Rx, Y: Ry}

	p.sessionOrd.Add(p.sessionOrd, big.NewInt(1))
	r, tx, ty := p.commitProve(&ecdsa.PrivateKey{PublicKey: R1, D: p.signKey}, p.makeSessionIdent(p.sessionOrd))

	return &SignCommitProve{r, tx, ty, Rx, Ry}
}

type SignCommitProve struct {
	R, Tx, Ty *big.Int // proof elements
	Rx, Ry    *big.Int // elements of gen ^ signKey
}

func (cp *SignCommitProve) checkCommit(checkCP *SignCommitProve) bool {
	return cp.R.Cmp(checkCP.R) == 0 && cp.Tx.Cmp(checkCP.Tx) == 0 && cp.Ty.Cmp(cp.Ty) == 0
}

func (p *TPTDProtocol) clearRound() {
	p.signKey = nil
	p.p1CP = nil
	p.p2CP = nil
}

func (p *TPTDProtocol) P1M1() (*SignCommitProve, error) {
	p.p1CP = p.generateSignKeyAndProof()
	commitProof := *p.p1CP
	commitProof.Rx = nil
	commitProof.Ry = nil
	return &commitProof, nil
}

func (p *TPTDProtocol) P2M1(p1CP *SignCommitProve) (*SignCommitProve, error) {
	p.p1CP = p1CP // store P1's opening proof
	// p1 will have incremented their session ord
	p.sessionOrd.Add(p.sessionOrd, big.NewInt(1))
	// this also inits signKey
	return p.generateSignKeyAndProof(), nil
}

func (p *TPTDProtocol) makeSessionIdent(ord *big.Int) []byte {
	ident := make([]byte, len(p.sessionId))
	copy(ident, p.sessionId)
	return append(ident, ord.Bytes()...)
}

func (p *TPTDProtocol) P1M2(p2CP *SignCommitProve) (*SignCommitProve, error) {

	// p2 will have incremented their session ord
	p.sessionOrd.Add(p.sessionOrd, big.NewInt(1))
	verify := p.proveVerify(p2CP.R, p2CP.Tx, p2CP.Ty, p2CP.Rx, p2CP.Ry, p.makeSessionIdent(p.sessionOrd))
	if !verify {
		return nil, fmt.Errorf("protocol failure - proof did not verify")
	}

	p.p2CP = p2CP;
	return p.p1CP, nil
}

func (p *TPTDProtocol) P2M2(p1CP *SignCommitProve, msgHash []byte) ([]byte, error) {

	if !p.p1CP.checkCommit(p1CP) {
		return nil, fmt.Errorf("protocol failure - commit failure")
	}

	// p1's proof session ord should be one behind me right now
	checkSessionOrd := big.NewInt(-1)
	checkSessionOrd.Add(checkSessionOrd, p.sessionOrd)
	verify := p.proveVerify(p1CP.R, p1CP.Tx, p1CP.Ty, p1CP.Rx, p1CP.Ry, p.makeSessionIdent(checkSessionOrd))
	if !verify {
		return nil, fmt.Errorf("protocol failure - proof did not verify")
	}

	Zq := p.theCurve.Params().N

	Rx2, _ := p.theCurve.ScalarMult(p1CP.Rx, p1CP.Ry, p.signKey.Bytes())
	r2 := new(big.Int).Mod(Rx2, Zq)

	Zq2 := new(big.Int).Exp(Zq, big.NewInt(2), nil)
	rho := MakeRandoIntWithOrder(Zq2)

	mPrime := new(big.Int).SetBytes(msgHash)

	// compute c1 ...
	qRho := new(big.Int).Mul(rho, Zq) // assume not mod since easily within order of Paillier
	xx := new(big.Int).ModInverse(p.signKey, Zq) // signKey is changed here ...?
	xx.Mul(xx, mPrime)
	xx.Mod(xx, Zq)
	xx.Add(xx, qRho)

	c1, _ := paillier.Encrypt(p.sessionPK, xx.Bytes())

	// compute v ...
	v := new(big.Int).ModInverse(p.signKey, Zq)
	v.Mul(v, r2)
	v.Mul(v, p.keyShare)
	v.Mod(v, Zq)

	c2 := paillier.Mul(p.sessionPK, p.cKey, v.Bytes())

	c3 := paillier.AddCipher(p.sessionPK, c1, c2)

	p.clearRound()

	return c3, nil
}

func (p *TPTDProtocol) P1Gen(c3, msgHash []byte) (*big.Int, *big.Int, error) {

	Zq := p.theCurve.Params().N

	Rx1, _ := p.theCurve.ScalarMult(p.p2CP.Rx, p.p2CP.Ry, p.signKey.Bytes())
	r := new(big.Int).Mod(Rx1, Zq)

	spBytes, _ := paillier.Decrypt(p.sessionSK, c3)
	sp := new(big.Int).SetBytes(spBytes)
	sp.Mod(sp, Zq)
	spp := new(big.Int).ModInverse(p.signKey, Zq)
	spp.Mul(spp, sp)
	spp.Mod(spp, Zq)

	s := spp
	maybeSmaller := new(big.Int).Sub(Zq, spp)
	if maybeSmaller.Cmp(s) < 0 {
		s = maybeSmaller
	}

	p.clearRound()

	return r, s, nil
}





