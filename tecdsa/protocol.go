package tecdsa

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"fmt"
	"github.com/roasbeef/go-go-gadget-paillier"
	"hash"
	"math/big"
)

// TODO: gotta be the same function somewhere else ...? maybe not public tho :/
func makeRandoIntWithOrder(N *big.Int) *big.Int {
	randoIntBytes := make([]byte, N.BitLen() / 8)
	rand.Read(randoIntBytes)
	randoInt := new(big.Int).SetBytes(randoIntBytes)
	randoInt.Mod(randoInt, N) // make sure rando is in ZN
	return randoInt
}

type TwoPartyTrustedDealerProtocol struct {
	theCurve elliptic.Curve
	hasher  func() hash.Hash

	// dealer items
	sessionKey *paillier.PrivateKey
	cKey []byte

	// shared state for protcol
	sessionId []byte // something like hash of session keys?
	sessionOrd *big.Int

	// P1 state
	k1 *big.Int

}
type TPTDProtocol TwoPartyTrustedDealerProtocol // abbreviation :)

func (p *TPTDProtocol) MakeKeyShares(privKey *big.Int) (*big.Int, *big.Int, error) {
	Zq := p.theCurve.Params().N

	// in the protocol i want to simulate we assume:
	// . alice has an existing public + private key pair
	// . alice acts as a trusted dealer and creates multiplicative shares of the private key x - which we call x1, x2
	x1 := makeRandoIntWithOrder(Zq)

	x2 := new(big.Int).ModInverse(x1, Zq)
	x2.Mul(x2, privKey)
	x2.Mod(x2, Zq)

	checkX := new(big.Int).Mul(x1, x2)
	checkX.Mod(checkX, Zq)

	if privKey.Cmp(checkX) != 0 {
		return nil, nil, fmt.Errorf("x1 and x2 should be multiplicative shares of x: %v, %v", x1, x2)
	}

	return x1, x2, nil
}

func (p *TPTDProtocol) InitSession(keyShare *big.Int) error {
	// dealer also defines parameters for Paillier encryption - if all goes according to plan only dealer's key pair is
	//  necessary. that is, the assumption is that dealer's public key is communicated to p2 and that is sufficient for the
	//  protocol. further, we want to assume that a fresh set of Paillier parameters is generated for each signing interaction.
	p.sessionKey, _ = paillier.GenerateKey(rand.Reader, 2048) // TODO: config params?

	/*
	TODO: Lindell's protocol assumes (?) that the Paillier key is generated by p1 and stored. cKey - the encryption
	 of p1's key share - is calculated, transmitted to p2 and also stored. If we don't want to do this - to avoid
	 storing the Paillier's keys for example - it's unclear that we can consider p1 a 'trusted dealer'...?
	 */
	var err error
	p.cKey, err = paillier.Encrypt(&p.sessionKey.PublicKey, keyShare.Bytes())
	if err != nil {
		return err
	}

	return nil
}

func computeChallenge(hasher hash.Hash, Gx, Tx, Ax *big.Int, optIdent []byte) *big.Int {
	hasher.Write(Gx.Bytes())
	hasher.Write(Tx.Bytes())
	hasher.Write(Ax.Bytes())
	hasher.Write(optIdent)
	return new(big.Int).SetBytes(hasher.Sum(nil))
}

// generates a Schnorr proof of knowledge of the discrete logarithm of the key, with commitment through the Fiat-Shamir transformation
// https://tools.ietf.org/html/rfc8235
func (p *TPTDProtocol) commitProve(A *ecdsa.PrivateKey, optIdent []byte) (r, tx, ty *big.Int) {

	hasher := p.hasher()
	theCurve := p.theCurve

	v := makeRandoIntWithOrder(theCurve.Params().N)
	tx, ty = theCurve.ScalarBaseMult(v.Bytes())

	// prover computes c = H(g, y, t)
	c := computeChallenge(hasher, theCurve.Params().Gx, tx, A.X, optIdent)

	// prover computes r = v - cx mod Zq and returns r to verifier.
	r = new(big.Int).Mul(c, A.D)
	r.Sub(v, r)
	r.Mod(r, theCurve.Params().N)

	return
}

func (p *TPTDProtocol) proveVerify(r, Tx, Ty, Ax, Ay *big.Int, optIdent []byte) bool {

	theCurve := p.theCurve
	hasher := p.hasher()

	// verifier computes challenge
	c := computeChallenge(hasher, theCurve.Params().Gx, Tx, Ax, optIdent)

	// verifier checks whether t = g^r * y^c.
	x1, y1 := theCurve.ScalarBaseMult(r.Bytes())
	x2, y2 := theCurve.ScalarMult(Ax, Ay, c.Bytes())
	zx, zy := theCurve.Add(x1, y1, x2, y2)

	if Tx.Cmp(zx) != 0 || Ty.Cmp(zy) != 0 {
		return false
	}
	return true
}

type MsgP1CommitProve struct {
	R, Tx, Ty *big.Int // proof elements
	R1x, R1y *big.Int // elements of gen ^ k1
}

/*
where 'sid' is session ID ...
1. P1’s first message:
	(a) P1 chooses a random k1 ← Zq and computes R1 = k1 · G.
	(b) P1 sends (com-prove, sid|1, R1, k1) to FRDLcom-zk.
 */
func (p *TPTDProtocol) P1CommitProve() MsgP1CommitProve {

	p.k1 = makeRandoIntWithOrder(p.theCurve.Params().N) // generate and save k1

	R1x, R1y := p.theCurve.ScalarBaseMult(p.k1.Bytes())
	R1 := ecdsa.PublicKey{Curve:p.theCurve, X: R1x, Y: R1y}

	sessIdent := append(p.sessionId, p.sessionOrd.Bytes()...) // TODO: helper?
	r, tx, ty := p.commitProve(&ecdsa.PrivateKey{PublicKey: R1, D: p.k1}, sessIdent)

	return MsgP1CommitProve{r, tx, ty, R1x, R1y}
}
